{-# OPTIONS_HADDOCK hide #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}
-- |
-- Copyright: (c) 2018-present Junyoung Clare Jang
-- License: BSD 3-Clause
--
-- Implementation detail of the transpiler from a miniCUTE program to a G-Machine program
module Minicute.Internal.Transpilers.GMachine
  ( transpileProgram

  , initialCode
  ) where

import Control.Lens.Each
import Control.Lens.Operators
import Control.Lens.Wrapped ( _Wrapped )
import Data.List
import Data.String
import Minicute.Data.GMachine.Instruction
import Minicute.Data.Minicute.Program

import qualified Data.Map as Map

-- * Transpilers
-- ** Calling Convention

-- $callingConvention
-- Which calling convention we gonna use?
--
-- 1. Try simple one
--
--     1. caller
--
--         - Push arguments in caller
--         - Evaluate result in caller
--
--     1. callee
--
--         - Update results in callee
--         - Pop arguments in callee

-- ** Transpiler Functions
-- *** Transpilers for a Program

-- |
-- Transpiler for a __Program__.
transpileProgram :: MainProgram 'Simple 'LLMC -> GMachineProgram
transpileProgram program = program ^. _Wrapped <&> transpileSc

-- |
-- Transpiler for a __S__uper__c__ombinator (top-level function definition).
transpileSc :: MainSupercombinator 'Simple 'LLMC -> GMachineSupercombinator
transpileSc sc = (scBinder, scArgsLength, scInsts)
  where
    scBinder = sc ^. _supercombinatorBinder

    scInsts = sc ^. _supercombinatorBody & transpileRE scArgsEnv

    scArgsEnv = Map.fromList $ zip scArgs [0..]
    scArgsLength = length scArgs
    scArgs = sc ^. _supercombinatorArguments

-- *** Transpilers for an Expression
-- |
-- Transpiler for a __R__oot __E__xpression.
transpileRE :: TranspilerE (MainExpression 'Simple 'LLMC)
transpileRE env (EInteger _ n) = [IPushBasicValue n, IUpdateAsInteger (getEnvSize env), IReturn]
transpileRE env (EConstructor _ tag 0) = [IPushBasicValue tag, IUpdateAsStructure (getEnvSize env), IReturn]
transpileRE env e@(EApplication2 _ _ (EPrimitive _ prim) _ _)
  | Just _ <- lookup prim binaryPrimitivePrecedenceTable
  = transpilePE env e <> [IUpdateAsInteger (getEnvSize env), IReturn]
transpileRE env (ELet _ flag lDefs body) = transpileLet transpileRE env (flag, lDefs, body)
transpileRE env (EMatch _ body mCases) = transpileMatch transpileSE (const transpileRE) env (body, mCases)
-- Should following really use a strict expression?
transpileRE env e = transpileSE env e <> [IUpdate envSize1, IPop envSize1, IUnwind]
  where
    envSize1 = getEnvSize1 env

-- |
-- Transpiler for a __S__trict __E__xpression.
-- All instruction generated by this transpiler should put the address of a whnf node on the top of the stack.
--
-- This transpiler is not able to directly transpile variable expressions because value of variable can be a non-whnf node.
transpileSE :: TranspilerE (MainExpression 'Simple 'LLMC)
transpileSE _ (EInteger _ n) = [IMakeInteger n]
transpileSE _ (EConstructor _ tag 0) = [IMakeStructure tag 0]
transpileSE _ (EConstructor _ tag arity) = [IMakeConstructor tag arity]
transpileSE env e@(EApplication2 _ _ (EPrimitive _ prim) _ _)
  | Just _ <- lookup prim binaryPrimitivePrecedenceTable
  = transpilePE env e <> [IWrapAsInteger]
transpileSE env e = transpileNE env e <> [IEval]

-- |
-- Transpiler for a __P__rimitive __E__xpression.
-- All instruction generated by this transpiler should put a primitive value on the top of the value stack.
transpilePE :: TranspilerE (MainExpression 'Simple 'LLMC)
transpilePE _ (EInteger _ n) = [IPushBasicValue n]
transpilePE _ (EConstructor _ tag 0) = [IPushBasicValue tag]
transpilePE env (EApplication2 _ _ (EPrimitive _ prim) e1 e2)
  | Just _ <- lookup prim binaryPrimitivePrecedenceTable
  = transpilePE env e1 <> transpilePE env e2 <> [IPrimitive prim]
transpilePE env (ELet _ flag lDefs body) = transpileLet transpilePE env (flag, lDefs, body) <> [IPop (length lDefs)]
transpilePE env e = transpileSE env e <> [IPushExtractedValue]

-- |
-- Transpiler for a __N__on-strict __E__xpression.
-- All instruction generated by this transpiler should put the address of a node on the top of the stack.
transpileNE :: TranspilerE (MainExpression 'Simple 'LLMC)
transpileNE _ (EInteger _ n) = [IMakeInteger n]
transpileNE _ (EConstructor _ tag 0) = [IMakeStructure tag 0]
transpileNE _ (EConstructor _ tag arity) = [IMakeConstructor tag arity]
transpileNE env (EVariable _ v)
  | Just index <- Map.lookup v env = [ICopy index]
  | otherwise = [IMakeGlobal v]
transpileNE _ (EPrimitive _ prim) = [IMakeGlobal . fromString . toString $ prim]
transpileNE env (EApplication _ e1 e2)
  = transpileNE env e1 <> transpileNE (addEnvOffset1 env) e2 <> [IMakeApplication]
transpileNE env (ELet _ flag lDefs body) = transpileLet transpileNE env (flag, lDefs, body) <> [IDig (length lDefs)]
transpileNE _ _ = error "Not yet implemented"

-- *** Transpilers for others
-- |
-- Transpiler for a __Let__ expression.
transpileLet :: TranspilerE (MainExpression 'Simple 'LLMC) -> TranspilerE (IsRecursive, [MainLetDefinition 'Simple 'LLMC], MainExpression 'Simple 'LLMC)
transpileLet transpileBody env (flag, lDefs, body)
  | isRecursive flag = transpileLetRecDefs env' lDefs <> bodyInst
  | otherwise = transpileLetDefs env lDefs <> bodyInst
  where
    bodyInst = transpileBody env' body
    env' = updateLetEnv lDefs env

transpileLetDefs :: TranspilerE [MainLetDefinition 'Simple 'LLMC]
transpileLetDefs env lDefs
  = concat (zipWith transpileNE envs lDefsBodies)
  where
    envs = iterate addEnvOffset1 env
    lDefsBodies = lDefs ^.. each . _letDefinitionBody

transpileLetRecDefs :: TranspilerE [MainLetDefinition 'Simple 'LLMC]
transpileLetRecDefs env lDefs
  = [IMakePlaceholders len] <> concatMap ((<> [IUpdate len]) . transpileNE env) lDefsBodies
  where
    lDefsBodies = lDefs ^.. each . _letDefinitionBody
    len = length lDefs

updateLetEnv :: [MainLetDefinition 'Simple 'LLMC] -> TranspilerEEnv -> TranspilerEEnv
updateLetEnv lDefs env = envOfLDefs <> addEnvOffset len env
  where
    envOfLDefs = Map.fromList (zip lDefsBinders [len - 1, len - 2 .. 0])
    lDefsBinders = lDefs ^.. each . _letDefinitionBinder
    len = length lDefs

-- |
-- Transpiler for a __Match__ expression.
transpileMatch :: TranspilerE (MainExpression 'Simple 'LLMC) -> (Integer -> TranspilerE (MainExpression 'Simple 'LLMC)) -> TranspilerE (MainExpression 'Simple 'LLMC, [MainMatchCase 'Simple 'LLMC])
transpileMatch transpileBody transpileCase env (body, mCases) = bodyInst <> [IMatch (makeMatchTable transpileCase env mCases)]
  where
    bodyInst = transpileBody env body

makeMatchTable :: (Integer -> TranspilerE (MainExpression 'Simple 'LLMC)) -> TranspilerEEnv -> [MainMatchCase 'Simple 'LLMC] -> MatchTable
makeMatchTable transpileCase env = MatchTable . fmap (makeMatchEntry transpileCase env)

makeMatchEntry :: (Integer -> TranspilerE (MainExpression 'Simple 'LLMC)) -> TranspilerEEnv -> MainMatchCase 'Simple 'LLMC -> MatchEntry
makeMatchEntry transpileCase env mCase = MatchEntry (caseTag, caseInst)
  where
    caseInst = [IDestruct caseArgsLen] <> transpileCase caseArgsLen env' caseBody
    caseBody = mCase ^. _matchCaseBody
    caseTag = mCase ^. _matchCaseTag

    env' = Map.fromList (zip caseArgs [0..]) <> addEnvOffset (fromInteger caseArgsLen) env

    caseArgsLen = genericLength caseArgs
    caseArgs = mCase ^. _matchCaseArguments

-- ** Types
-- |
-- A transpiler that uses 'TranspilerEEnv' and @a@ to build 'GMachineExpression'
type TranspilerE a = TranspilerEEnv -> a -> GMachineExpression

-- |
-- Environment type used for expression transpilers
type TranspilerEEnv = Map.Map Identifier Int

getEnvSize1 :: TranspilerEEnv -> Int
getEnvSize1 = (+ 1) . getEnvSize

getEnvSize :: TranspilerEEnv -> Int
getEnvSize = Map.size

addEnvOffset1 :: TranspilerEEnv -> TranspilerEEnv
addEnvOffset1 = Map.map (+ 1)

addEnvOffset :: Int -> TranspilerEEnv -> TranspilerEEnv
addEnvOffset n = Map.map (+ n)


-- * Initial Instructions
-- |
-- Initial instructions used to start any program.
initialCode ::[Instruction]
initialCode = [IMakeGlobal "main", IEval]
