{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveLift #-}
{-# LANGUAGE OverloadedStrings #-}
module Minicute.Types.GMachine.Instruction
  ( -- * G-Machine Architecture

    -- ** Abstract Structure
    -- $abstractStructure

    -- ** Operational Semantics
    -- $operationalSemantics

    -- ** Instructions
    initialCode

  , GMachineProgram
  , GMachineSupercombinator
  , GMachineExpression
  , Instruction( .. )
  , PrimitiveOperator( .. )
  , MatchTable( .. )
  , MatchEntry( .. )

    -- * Transpilers
    {-|
__TODO: This part should be extracted into separated module.__
-}
    -- ** Calling Convention
    -- $callingConvention

    -- ** Transpiler Functions
    -- *** Transpilers for a Program
  , transpileProgram
  , transpileSc

    -- *** Transpilers for an Expression
  , TranspilerE
  , TranspileEEnv
  , transpileRE
  , transpileSE
  , transpileNE
  , transpilePE

    -- *** Transpilers for others
  , transpileLet
  , transpileMatch
  ) where

import Control.Lens.Each
import Control.Lens.Operators
import Control.Lens.Wrapped ( _Wrapped )
import Data.Data
import Data.List
import GHC.Generics
import Language.Haskell.TH.Syntax
import Minicute.Types.Minicute.Precedence
import Minicute.Types.Minicute.Program

import qualified Data.Map as Map

type GMachineExpression = [Instruction]
{- |
[@Identifier@] The identifier for the Supercombinator.

[@Int@] The arity of the Supercombinator.

[@GMachineExpression@] The code for the Supercombinator.
-}
type GMachineSupercombinator = (Identifier, Int, GMachineExpression)
type GMachineProgram = [GMachineSupercombinator]

{- $callingConvention
Which calling convention we gonna use?

1. Try simple one

    1. caller

        - Push arguments in caller
        - Evaluate result in caller

    1. callee

        - Update results in callee
        - Pop arguments in callee
-}

{-|
Transpiler for a __Program__.
-}
transpileProgram :: MainProgram -> GMachineProgram
transpileProgram program = program ^. _Wrapped <&> transpileSc

initialCode ::[Instruction]
initialCode = [IMakeGlobal "main", IEval]

{-|
Transpiler for a __S__uper__c__ombinator (top-level function definition).
-}
transpileSc :: MainSupercombinator -> GMachineSupercombinator
transpileSc sc = (scBinder, scArgsLength, scInsts)
  where
    scBinder = sc ^. _supercombinatorBinder

    scInsts = sc ^. _supercombinatorBody & transpileRE scArgsEnv

    scArgsEnv = Map.fromList $ zip scArgs [0..]
    scArgsLength = length scArgs
    scArgs = sc ^. _supercombinatorArguments

type TranspilerE a = TranspileEEnv -> a -> GMachineExpression

{-|
Transpiler for a __R__oot __E__xpression.
-}
transpileRE :: TranspilerE MainExpression
transpileRE env (EInteger n) = [IPushBasicValue n, IUpdateAsInteger (getEnvSize env), IReturn]
transpileRE env (EConstructor tag 0) = [IPushBasicValue tag, IUpdateAsConstructor (getEnvSize env), IReturn]
transpileRE env e@(EApplication2 (EVariableIdentifier op) _ _)
  | Just _ <- lookup op binaryIntegerPrecendenceTable
  = transpilePE env e <> [IUpdateAsInteger (getEnvSize env), IReturn]
  | Just _ <- lookup op binaryDataPrecendenceTable
  = transpilePE env e <> [IUpdateAsConstructor (getEnvSize env), IReturn]
transpileRE env (ELet flag lDefs body) = transpileLet transpileRE env (flag, lDefs, body)
transpileRE env (EMatch body mCases) = transpileMatch transpileSE (const transpileRE) env (body, mCases)
-- Should following really use a strict expression?
transpileRE env e = transpileSE env e <> [IUpdate envSize1, IPop envSize1, IUnwind]
  where
    envSize1 = getEnvSize1 env

{-|
Transpiler for a __S__trict __E__xpression.
All instruction generated by this transpiler should put the address of a whnf node on the top of the stack.

This transpiler is not able to directly transpile variable expressions because value of variable can be a non-whnf node.
-}
transpileSE :: TranspilerE MainExpression
transpileSE _ (EInteger n) = [IMakeInteger n]
transpileSE _ (EConstructor tag arity) = [IMakeConstructor tag arity]
transpileSE env e@(EApplication2 (EVariableIdentifier op) _ _)
  | Just _ <- lookup op binaryIntegerPrecendenceTable
  = transpilePE env e <> [IWrapAsInteger]
  | Just _ <- lookup op binaryDataPrecendenceTable
  = transpilePE env e <> [IWrapAsConstructor]
transpileSE env e = transpileNE env e <> [IEval]

{-|
Transpiler for a __P__rimitive __E__xpression.
All instruction generated by this transpiler should put a primitive value on the top of the value stack.
-}
transpilePE :: TranspilerE MainExpression
transpilePE _ (EInteger n) = [IPushBasicValue n]
transpilePE _ (EConstructor tag 0) = [IPushBasicValue tag]
transpilePE env (EApplication2 (EVariableIdentifier op) e1 e2)
  | Just _ <- lookup op binaryPrecedenceTable
  = transpilePE env e1 <> transpilePE env e2 <> [IPrimitive (getPrimitiveOperator op)]
transpilePE env (ELet flag lDefs body) = transpileLet transpilePE env (flag, lDefs, body) <> [IPop (length lDefs)]
transpilePE env e = transpileSE env e <> [IPushExtractedValue]

{-|
Transpiler for a __N__on-strict __E__xpression.
All instruction generated by this transpiler should put the address of a node on the top of the stack.
-}
transpileNE :: TranspilerE MainExpression
transpileNE _ (EInteger n) = [IMakeInteger n]
transpileNE _ (EConstructor tag arity) = [IMakeConstructor tag arity]
transpileNE env (EVariable v)
  | Just index <- Map.lookup v env = [ICopyArgument index]
  | otherwise = [IMakeGlobal v]
transpileNE env (EApplication e1 e2)
  = transpileNE env e1 <> transpileNE (addEnvOffset1 env) e2 <> [IMakeApplication]
transpileNE env (ELet flag lDefs body) = transpileLet transpileNE env (flag, lDefs, body) <> [IDig (length lDefs)]
transpileNE _ _ = error "Not yet implemented"

{-|
Transpiler for a __Let__ expression.
-}
transpileLet :: TranspilerE MainExpression -> TranspilerE (IsRecursive, [MainLetDefinition], MainExpression)
transpileLet transpileBody env (flag, lDefs, body)
  | isRecursive flag = transpileLetRecDefs env' lDefs <> bodyInst
  | otherwise = transpileLetDefs env lDefs <> bodyInst
  where
    bodyInst = transpileBody env' body
    env' = updateLetEnv lDefs env

transpileLetDefs :: TranspilerE [MainLetDefinition]
transpileLetDefs env lDefs
  = concat (zipWith transpileNE envs lDefsBodies)
  where
    envs = iterate addEnvOffset1 env
    lDefsBodies = lDefs ^.. each . _letDefinitionBody

transpileLetRecDefs :: TranspilerE [MainLetDefinition]
transpileLetRecDefs env lDefs
  = [IMakePlaceholders len] <> concatMap ((<> [IUpdate len]) . transpileNE env) lDefsBodies
  where
    lDefsBodies = lDefs ^.. each . _letDefinitionBody
    len = length lDefs

updateLetEnv :: [MainLetDefinition] -> TranspileEEnv -> TranspileEEnv
updateLetEnv lDefs env = envOfLDefs <> addEnvOffset len env
  where
    envOfLDefs = Map.fromList (zip lDefsBinders [len - 1, len - 2 .. 0])
    lDefsBinders = lDefs ^.. each . _letDefinitionBinder
    len = length lDefs

{-|
Transpiler for a __Match__ expression.
-}
transpileMatch :: TranspilerE MainExpression -> (Integer -> TranspilerE MainExpression) -> TranspilerE (MainExpression, [MainMatchCase])
transpileMatch transpileBody transpileCase env (body, mCases) = bodyInst <> [IMatch (makeMatchTable transpileCase env mCases)]
  where
    bodyInst = transpileBody env body

makeMatchTable :: (Integer -> TranspilerE MainExpression) -> TranspileEEnv -> [MainMatchCase] -> MatchTable
makeMatchTable transpileCase env = MatchTable . fmap (makeMatchEntry transpileCase env)

makeMatchEntry :: (Integer -> TranspilerE MainExpression) -> TranspileEEnv -> MainMatchCase -> MatchEntry
makeMatchEntry transpileCase env mCase = MatchEntry (caseTag, caseInst)
  where
    caseInst = [IDestruct caseArgsLen] <> transpileCase caseArgsLen env' caseBody
    caseBody = mCase ^. _matchCaseBody
    caseTag = mCase ^. _matchCaseTag

    env' = Map.fromList (zip caseArgs [0..]) <> addEnvOffset (fromInteger caseArgsLen) env

    caseArgsLen = genericLength caseArgs
    caseArgs = mCase ^. _matchCaseArguments

type TranspileEEnv = Map.Map Identifier Int

getEnvSize1 :: TranspileEEnv -> Int
getEnvSize1 = (+ 1) . getEnvSize

getEnvSize :: TranspileEEnv -> Int
getEnvSize = Map.size

addEnvOffset1 :: TranspileEEnv -> TranspileEEnv
addEnvOffset1 = Map.map (+ 1)

addEnvOffset :: Int -> TranspileEEnv -> TranspileEEnv
addEnvOffset n = Map.map (+ n)

{- $abstractStructure
This G-Machine is represented by 5-tuple.

@(CurrentCode, AddressStack, ValueStack, NodeHeap, GlobalEnvironment)@

[@CurrentCode@] a list of codes currently executed.

[@AddressStack@] a stack of G-Machine addresses.

[@ValueStack@] a stack of primitive values.

[@NodeHeap@] a heap of G-Machine nodes.

[@GlobalEnvironment@] a map from identifiers to addresses of corresponding nodes.
-}
{- $operationalSemantics
Any unspecified cases mean erratic state.

=== Basic Node Creating Operations
- __IMakeInteger__

    > (IMakeInteger n : codes,        addrs, values, heap,                   global)
    > ------------------------------------------------------------------------------
    > (                 codes, addr : addrs, values, heap[addr: NInteger n], global)

- __IMakeConstructor__

    > (IMakeConstructor t a : codes,        addrs, values, heap,                         global)
    > ------------------------------------------------------------------------------------------
    > (                       codes, addr : addrs, values, heap[addr: NConstructor t a], global)

- __IMakeApplication__

    > (IMakeApplication : codes, addr_0 : addr_1 : addrs, values, heap,                                   global)
    > -----------------------------------------------------------------------------------------------------------
    > (                   codes,            addr : addrs, values, heap[addr: NApplication addr_1 addr_0], global)

- __IMakeGlobal__

    > (IMakeGlobal id : codes,        addrs, values, heap, global[id: addr])
    > ----------------------------------------------------------------------
    > (                 codes, addr : addrs, values, heap, global[id: addr])

- __IMakePlaceholders__

    > (IMakePlaceholders n : codes,                                  addrs, values, heap,  global)
    > --------------------------------------------------------------------------------------------
    > (                      codes, addr_0 : addr_1 : ... : addr_n : addrs, values, heap', global)
    >
    > heap' = heap[addr_0: NEmpty, addr_1: NEmpty, ..., addr_n: NEmpty]

    Do we need to add @NEmpty@ or just use @NIndirect nullAddr@?

=== Address Stack Based Operations
- __IPop__

    > (IPop n : codes, addr_0 : addr_1 : ... : addr_(n - 1) : addrs, values, heap, global)
    > ------------------------------------------------------------------------------------
    > (         codes,                                        addrs, values, heap, global)

- __IDig__

    > (IDig n : codes, addr_0 : addr_1 : ... : addr_n : addrs, values, heap, global)
    > ------------------------------------------------------------------------------
    > (         codes,                         addr_0 : addrs, values, heap, global)

- __IUpdate__

    > (IUpdate n : codes, addr_0 : addr_1 : ... : addr_n : addrs, values, heap,                           global)
    > -----------------------------------------------------------------------------------------------------------
    > (            codes,          addr_1 : ... : addr_n : addrs, values, heap[addr_n: NIndirect addr_0], global)

- __ICopyArgument__

    > (ICopyArgument n : codes,          addr_0 : addr_1 : ... : addr_n : addrs, values, heap, global)
    > ------------------------------------------------------------------------------------------------
    > (                  codes, addr_n : addr_0 : addr_1 : ... : addr_n : addrs, values, heap, global)

=== Value Stack Based Operations
- __IPushBasicValue__

    > (IPushBasicValue v : codes, addrs,     values, heap, global)
    > ------------------------------------------------------------
    > (                    codes, addrs, v : values, heap, global)

- __IPushExtractedValue__

    > (IPushExtractedValue : codes, addr : addrs,     values, heap[addr: NInteger v], global)
    > ---------------------------------------------------------------------------------------
    > (                      codes,        addrs, v : values, heap,                   global)

    > (IPushExtractedValue : codes, addr : addrs,     values, heap[addr: NStructure v 0], global)
    > -------------------------------------------------------------------------------------------
    > (                      codes,        addrs, v : values, heap,                       global)

- __IWrapAsInteger__

    > (IWrapAsInteger : codes,        addrs, v : values, heap,                   global)
    > ----------------------------------------------------------------------------------
    > (                 codes, addr : addrs,     values, heap[addr: NInteger v], global)

- __IWrapAsConstructor__

    __TODO: Rename this instruction.__

    > (IWrapAsConstructor : codes,        addrs, v : values, heap,                       global)
    > ------------------------------------------------------------------------------------------
    > (                     codes, addr : addrs,     values, heap[addr: NStructure v 0], global)

- __IUpdateAsInteger__

    > (IUpdateAsInteger n : codes, addr_0 : addr_1 : ... : addr_n : addrs, v : values, heap,                     global)
    > ------------------------------------------------------------------------------------------------------------------
    > (                     codes, addr_0 : addr_1 : ... : addr_n : addrs,     values, heap[addr_n: NInteger v], global)

- __IUpdateAsConstructor__

    __TODO: Rename this instruction.__

    > (IUpdateAsConstructor n : codes, addr_0 : addr_1 : ... : addr_n : addrs, v : values, heap,                         global)
    > --------------------------------------------------------------------------------------------------------------------------
    > (                         codes, addr_0 : addr_1 : ... : addr_n : addrs,     values, heap[addr_n: NStructure v 0], global)

=== Primitive Operations
- __IPrimitive__

    > (IPrimitive op : codes, addrs, v_0 : v_1 : values, heap, global)
    > ----------------------------------------------------------------
    > (                codes, addrs,        v' : values, heap, global)
    >
    > v' = v_0 R v1
    > (when op represents a binary operation R)

    > (IPrimitive op : codes, addrs,  v : values, heap, global)
    > ---------------------------------------------------------
    > (                codes, addrs, v' : values, heap, global)
    >
    > v' = R v
    > (when op represents a unary operation R)

__TODO: Add rest of operation semantics.__
-}

data Instruction
  -- Basic node creating operations
  = IMakeInteger Integer
  | IMakeConstructor Integer Integer
  | IMakeApplication
  | IMakeGlobal Identifier
  | IMakePlaceholders Int

  -- Address Stack based operations
  | IPop Int
  | IDig Int
  | IUpdate Int
  | ICopyArgument Int

  -- Value stack based operations
  | IPushBasicValue Integer
  | IPushExtractedValue
  | IWrapAsInteger
  | IWrapAsConstructor
  | IUpdateAsInteger Int
  | IUpdateAsConstructor Int

  -- Primitive operations
  | IPrimitive PrimitiveOperator

  -- Node inspecting operations
  | IUnwind
  | IDestruct Integer

  -- Dump related operations
  | IEval
  | IReturn

  -- Match related operations
  | IMatch MatchTable
  deriving ( Generic
           , Typeable
           , Data
           , Lift
           , Eq
           , Ord
           , Show
           )

newtype MatchTable
  = MatchTable [MatchEntry]
  deriving ( Generic
           , Typeable
           , Data
           , Lift
           , Eq
           , Ord
           , Show
           )

newtype MatchEntry
  = MatchEntry (Integer, GMachineExpression)
  deriving ( Generic
           , Typeable
           , Data
           , Lift
           , Eq
           , Ord
           , Show
           )

data PrimitiveOperator
  = POAdd
  | POSub
  | POMul
  | PODiv
  deriving ( Generic
           , Typeable
           , Data
           , Lift
           , Eq
           , Ord
           , Show
           )

getPrimitiveOperator :: String -> PrimitiveOperator
getPrimitiveOperator "+" = POAdd
getPrimitiveOperator "-" = POSub
getPrimitiveOperator "*" = POMul
getPrimitiveOperator "/" = PODiv
getPrimitiveOperator _ = error "Not implemented yet"
